// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.1
// source: proto/yt_scraper.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Album, Artist, QuickPick, SearchAlbum, SearchArtist, SuggestedLink, Track } from "./common.js";

export const protobufPackage = "yt_scraper";

export interface GetSearchSuggestionsRequest {
  query: string;
}

export interface GetSearchSuggestionsResponse {
  suggestedQueries: string[];
  suggestedLinks: SuggestedLink[];
}

export interface GetQuickPicksRequest {
  /** Region/Country code. (Like US, UK, IN) */
  gl: string;
}

export interface GetQuickPicksResponse {
  quickPicks: QuickPick[];
}

export interface SearchTracksRequest {
  query: string;
}

export interface SearchTracksResponse {
  tracks: Track[];
}

export interface GetAlbumDetailsRequest {
  albumId: string;
}

export interface GetAlbumDetailsResponse {
  album: Album | undefined;
}

export interface SearchArtistsRequest {
  query: string;
}

export interface SearchArtistsResponse {
  artists: SearchArtist[];
}

export interface SearchAlbumsRequest {
  query: string;
}

export interface SearchAlbumsResponse {
  albums: SearchAlbum[];
}

export interface GetArtistDetailsRequest {
  browseId: string;
}

export interface GetArtistDetailsResponse {
  artist: Artist | undefined;
}

function createBaseGetSearchSuggestionsRequest(): GetSearchSuggestionsRequest {
  return { query: "" };
}

export const GetSearchSuggestionsRequest: MessageFns<GetSearchSuggestionsRequest> = {
  encode(message: GetSearchSuggestionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSearchSuggestionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSearchSuggestionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSearchSuggestionsRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: GetSearchSuggestionsRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSearchSuggestionsRequest>, I>>(base?: I): GetSearchSuggestionsRequest {
    return GetSearchSuggestionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSearchSuggestionsRequest>, I>>(object: I): GetSearchSuggestionsRequest {
    const message = createBaseGetSearchSuggestionsRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseGetSearchSuggestionsResponse(): GetSearchSuggestionsResponse {
  return { suggestedQueries: [], suggestedLinks: [] };
}

export const GetSearchSuggestionsResponse: MessageFns<GetSearchSuggestionsResponse> = {
  encode(message: GetSearchSuggestionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.suggestedQueries) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.suggestedLinks) {
      SuggestedLink.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSearchSuggestionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSearchSuggestionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.suggestedQueries.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.suggestedLinks.push(SuggestedLink.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSearchSuggestionsResponse {
    return {
      suggestedQueries: globalThis.Array.isArray(object?.suggestedQueries)
        ? object.suggestedQueries.map((e: any) => globalThis.String(e))
        : [],
      suggestedLinks: globalThis.Array.isArray(object?.suggestedLinks)
        ? object.suggestedLinks.map((e: any) => SuggestedLink.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSearchSuggestionsResponse): unknown {
    const obj: any = {};
    if (message.suggestedQueries?.length) {
      obj.suggestedQueries = message.suggestedQueries;
    }
    if (message.suggestedLinks?.length) {
      obj.suggestedLinks = message.suggestedLinks.map((e) => SuggestedLink.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSearchSuggestionsResponse>, I>>(base?: I): GetSearchSuggestionsResponse {
    return GetSearchSuggestionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSearchSuggestionsResponse>, I>>(object: I): GetSearchSuggestionsResponse {
    const message = createBaseGetSearchSuggestionsResponse();
    message.suggestedQueries = object.suggestedQueries?.map((e) => e) || [];
    message.suggestedLinks = object.suggestedLinks?.map((e) => SuggestedLink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetQuickPicksRequest(): GetQuickPicksRequest {
  return { gl: "" };
}

export const GetQuickPicksRequest: MessageFns<GetQuickPicksRequest> = {
  encode(message: GetQuickPicksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gl !== "") {
      writer.uint32(10).string(message.gl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuickPicksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuickPicksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuickPicksRequest {
    return { gl: isSet(object.gl) ? globalThis.String(object.gl) : "" };
  },

  toJSON(message: GetQuickPicksRequest): unknown {
    const obj: any = {};
    if (message.gl !== "") {
      obj.gl = message.gl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuickPicksRequest>, I>>(base?: I): GetQuickPicksRequest {
    return GetQuickPicksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuickPicksRequest>, I>>(object: I): GetQuickPicksRequest {
    const message = createBaseGetQuickPicksRequest();
    message.gl = object.gl ?? "";
    return message;
  },
};

function createBaseGetQuickPicksResponse(): GetQuickPicksResponse {
  return { quickPicks: [] };
}

export const GetQuickPicksResponse: MessageFns<GetQuickPicksResponse> = {
  encode(message: GetQuickPicksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.quickPicks) {
      QuickPick.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuickPicksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuickPicksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quickPicks.push(QuickPick.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuickPicksResponse {
    return {
      quickPicks: globalThis.Array.isArray(object?.quickPicks)
        ? object.quickPicks.map((e: any) => QuickPick.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetQuickPicksResponse): unknown {
    const obj: any = {};
    if (message.quickPicks?.length) {
      obj.quickPicks = message.quickPicks.map((e) => QuickPick.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuickPicksResponse>, I>>(base?: I): GetQuickPicksResponse {
    return GetQuickPicksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuickPicksResponse>, I>>(object: I): GetQuickPicksResponse {
    const message = createBaseGetQuickPicksResponse();
    message.quickPicks = object.quickPicks?.map((e) => QuickPick.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchTracksRequest(): SearchTracksRequest {
  return { query: "" };
}

export const SearchTracksRequest: MessageFns<SearchTracksRequest> = {
  encode(message: SearchTracksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTracksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTracksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTracksRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: SearchTracksRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchTracksRequest>, I>>(base?: I): SearchTracksRequest {
    return SearchTracksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchTracksRequest>, I>>(object: I): SearchTracksRequest {
    const message = createBaseSearchTracksRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseSearchTracksResponse(): SearchTracksResponse {
  return { tracks: [] };
}

export const SearchTracksResponse: MessageFns<SearchTracksResponse> = {
  encode(message: SearchTracksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tracks) {
      Track.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTracksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTracksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tracks.push(Track.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTracksResponse {
    return { tracks: globalThis.Array.isArray(object?.tracks) ? object.tracks.map((e: any) => Track.fromJSON(e)) : [] };
  },

  toJSON(message: SearchTracksResponse): unknown {
    const obj: any = {};
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => Track.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchTracksResponse>, I>>(base?: I): SearchTracksResponse {
    return SearchTracksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchTracksResponse>, I>>(object: I): SearchTracksResponse {
    const message = createBaseSearchTracksResponse();
    message.tracks = object.tracks?.map((e) => Track.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAlbumDetailsRequest(): GetAlbumDetailsRequest {
  return { albumId: "" };
}

export const GetAlbumDetailsRequest: MessageFns<GetAlbumDetailsRequest> = {
  encode(message: GetAlbumDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.albumId !== "") {
      writer.uint32(10).string(message.albumId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAlbumDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAlbumDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.albumId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAlbumDetailsRequest {
    return { albumId: isSet(object.albumId) ? globalThis.String(object.albumId) : "" };
  },

  toJSON(message: GetAlbumDetailsRequest): unknown {
    const obj: any = {};
    if (message.albumId !== "") {
      obj.albumId = message.albumId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAlbumDetailsRequest>, I>>(base?: I): GetAlbumDetailsRequest {
    return GetAlbumDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAlbumDetailsRequest>, I>>(object: I): GetAlbumDetailsRequest {
    const message = createBaseGetAlbumDetailsRequest();
    message.albumId = object.albumId ?? "";
    return message;
  },
};

function createBaseGetAlbumDetailsResponse(): GetAlbumDetailsResponse {
  return { album: undefined };
}

export const GetAlbumDetailsResponse: MessageFns<GetAlbumDetailsResponse> = {
  encode(message: GetAlbumDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.album !== undefined) {
      Album.encode(message.album, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAlbumDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAlbumDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.album = Album.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAlbumDetailsResponse {
    return { album: isSet(object.album) ? Album.fromJSON(object.album) : undefined };
  },

  toJSON(message: GetAlbumDetailsResponse): unknown {
    const obj: any = {};
    if (message.album !== undefined) {
      obj.album = Album.toJSON(message.album);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAlbumDetailsResponse>, I>>(base?: I): GetAlbumDetailsResponse {
    return GetAlbumDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAlbumDetailsResponse>, I>>(object: I): GetAlbumDetailsResponse {
    const message = createBaseGetAlbumDetailsResponse();
    message.album = (object.album !== undefined && object.album !== null) ? Album.fromPartial(object.album) : undefined;
    return message;
  },
};

function createBaseSearchArtistsRequest(): SearchArtistsRequest {
  return { query: "" };
}

export const SearchArtistsRequest: MessageFns<SearchArtistsRequest> = {
  encode(message: SearchArtistsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchArtistsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchArtistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchArtistsRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: SearchArtistsRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchArtistsRequest>, I>>(base?: I): SearchArtistsRequest {
    return SearchArtistsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchArtistsRequest>, I>>(object: I): SearchArtistsRequest {
    const message = createBaseSearchArtistsRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseSearchArtistsResponse(): SearchArtistsResponse {
  return { artists: [] };
}

export const SearchArtistsResponse: MessageFns<SearchArtistsResponse> = {
  encode(message: SearchArtistsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.artists) {
      SearchArtist.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchArtistsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchArtistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artists.push(SearchArtist.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchArtistsResponse {
    return {
      artists: globalThis.Array.isArray(object?.artists)
        ? object.artists.map((e: any) => SearchArtist.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchArtistsResponse): unknown {
    const obj: any = {};
    if (message.artists?.length) {
      obj.artists = message.artists.map((e) => SearchArtist.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchArtistsResponse>, I>>(base?: I): SearchArtistsResponse {
    return SearchArtistsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchArtistsResponse>, I>>(object: I): SearchArtistsResponse {
    const message = createBaseSearchArtistsResponse();
    message.artists = object.artists?.map((e) => SearchArtist.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchAlbumsRequest(): SearchAlbumsRequest {
  return { query: "" };
}

export const SearchAlbumsRequest: MessageFns<SearchAlbumsRequest> = {
  encode(message: SearchAlbumsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAlbumsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAlbumsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAlbumsRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: SearchAlbumsRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchAlbumsRequest>, I>>(base?: I): SearchAlbumsRequest {
    return SearchAlbumsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchAlbumsRequest>, I>>(object: I): SearchAlbumsRequest {
    const message = createBaseSearchAlbumsRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseSearchAlbumsResponse(): SearchAlbumsResponse {
  return { albums: [] };
}

export const SearchAlbumsResponse: MessageFns<SearchAlbumsResponse> = {
  encode(message: SearchAlbumsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.albums) {
      SearchAlbum.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAlbumsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAlbumsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.albums.push(SearchAlbum.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAlbumsResponse {
    return {
      albums: globalThis.Array.isArray(object?.albums) ? object.albums.map((e: any) => SearchAlbum.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchAlbumsResponse): unknown {
    const obj: any = {};
    if (message.albums?.length) {
      obj.albums = message.albums.map((e) => SearchAlbum.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchAlbumsResponse>, I>>(base?: I): SearchAlbumsResponse {
    return SearchAlbumsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchAlbumsResponse>, I>>(object: I): SearchAlbumsResponse {
    const message = createBaseSearchAlbumsResponse();
    message.albums = object.albums?.map((e) => SearchAlbum.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetArtistDetailsRequest(): GetArtistDetailsRequest {
  return { browseId: "" };
}

export const GetArtistDetailsRequest: MessageFns<GetArtistDetailsRequest> = {
  encode(message: GetArtistDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.browseId !== "") {
      writer.uint32(10).string(message.browseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetArtistDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtistDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.browseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtistDetailsRequest {
    return { browseId: isSet(object.browseId) ? globalThis.String(object.browseId) : "" };
  },

  toJSON(message: GetArtistDetailsRequest): unknown {
    const obj: any = {};
    if (message.browseId !== "") {
      obj.browseId = message.browseId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtistDetailsRequest>, I>>(base?: I): GetArtistDetailsRequest {
    return GetArtistDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtistDetailsRequest>, I>>(object: I): GetArtistDetailsRequest {
    const message = createBaseGetArtistDetailsRequest();
    message.browseId = object.browseId ?? "";
    return message;
  },
};

function createBaseGetArtistDetailsResponse(): GetArtistDetailsResponse {
  return { artist: undefined };
}

export const GetArtistDetailsResponse: MessageFns<GetArtistDetailsResponse> = {
  encode(message: GetArtistDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artist !== undefined) {
      Artist.encode(message.artist, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetArtistDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtistDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artist = Artist.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtistDetailsResponse {
    return { artist: isSet(object.artist) ? Artist.fromJSON(object.artist) : undefined };
  },

  toJSON(message: GetArtistDetailsResponse): unknown {
    const obj: any = {};
    if (message.artist !== undefined) {
      obj.artist = Artist.toJSON(message.artist);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetArtistDetailsResponse>, I>>(base?: I): GetArtistDetailsResponse {
    return GetArtistDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetArtistDetailsResponse>, I>>(object: I): GetArtistDetailsResponse {
    const message = createBaseGetArtistDetailsResponse();
    message.artist = (object.artist !== undefined && object.artist !== null)
      ? Artist.fromPartial(object.artist)
      : undefined;
    return message;
  },
};

export type YTScraperService = typeof YTScraperService;
export const YTScraperService = {
  getSearchSuggestions: {
    path: "/yt_scraper.YTScraper/GetSearchSuggestions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSearchSuggestionsRequest): Buffer =>
      Buffer.from(GetSearchSuggestionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSearchSuggestionsRequest => GetSearchSuggestionsRequest.decode(value),
    responseSerialize: (value: GetSearchSuggestionsResponse): Buffer =>
      Buffer.from(GetSearchSuggestionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetSearchSuggestionsResponse => GetSearchSuggestionsResponse.decode(value),
  },
  getQuickPicks: {
    path: "/yt_scraper.YTScraper/GetQuickPicks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetQuickPicksRequest): Buffer => Buffer.from(GetQuickPicksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetQuickPicksRequest => GetQuickPicksRequest.decode(value),
    responseSerialize: (value: GetQuickPicksResponse): Buffer =>
      Buffer.from(GetQuickPicksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetQuickPicksResponse => GetQuickPicksResponse.decode(value),
  },
  getAlbumDetails: {
    path: "/yt_scraper.YTScraper/GetAlbumDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAlbumDetailsRequest): Buffer =>
      Buffer.from(GetAlbumDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAlbumDetailsRequest => GetAlbumDetailsRequest.decode(value),
    responseSerialize: (value: GetAlbumDetailsResponse): Buffer =>
      Buffer.from(GetAlbumDetailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetAlbumDetailsResponse => GetAlbumDetailsResponse.decode(value),
  },
  getArtistDetails: {
    path: "/yt_scraper.YTScraper/GetArtistDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetArtistDetailsRequest): Buffer =>
      Buffer.from(GetArtistDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetArtistDetailsRequest => GetArtistDetailsRequest.decode(value),
    responseSerialize: (value: GetArtistDetailsResponse): Buffer =>
      Buffer.from(GetArtistDetailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetArtistDetailsResponse => GetArtistDetailsResponse.decode(value),
  },
  searchTracks: {
    path: "/yt_scraper.YTScraper/SearchTracks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchTracksRequest): Buffer => Buffer.from(SearchTracksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SearchTracksRequest => SearchTracksRequest.decode(value),
    responseSerialize: (value: SearchTracksResponse): Buffer =>
      Buffer.from(SearchTracksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SearchTracksResponse => SearchTracksResponse.decode(value),
  },
  searchArtists: {
    path: "/yt_scraper.YTScraper/SearchArtists",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchArtistsRequest): Buffer => Buffer.from(SearchArtistsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SearchArtistsRequest => SearchArtistsRequest.decode(value),
    responseSerialize: (value: SearchArtistsResponse): Buffer =>
      Buffer.from(SearchArtistsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SearchArtistsResponse => SearchArtistsResponse.decode(value),
  },
  searchAlbums: {
    path: "/yt_scraper.YTScraper/SearchAlbums",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchAlbumsRequest): Buffer => Buffer.from(SearchAlbumsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SearchAlbumsRequest => SearchAlbumsRequest.decode(value),
    responseSerialize: (value: SearchAlbumsResponse): Buffer =>
      Buffer.from(SearchAlbumsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SearchAlbumsResponse => SearchAlbumsResponse.decode(value),
  },
} as const;

export interface YTScraperServer extends UntypedServiceImplementation {
  getSearchSuggestions: handleUnaryCall<GetSearchSuggestionsRequest, GetSearchSuggestionsResponse>;
  getQuickPicks: handleUnaryCall<GetQuickPicksRequest, GetQuickPicksResponse>;
  getAlbumDetails: handleUnaryCall<GetAlbumDetailsRequest, GetAlbumDetailsResponse>;
  getArtistDetails: handleUnaryCall<GetArtistDetailsRequest, GetArtistDetailsResponse>;
  searchTracks: handleUnaryCall<SearchTracksRequest, SearchTracksResponse>;
  searchArtists: handleUnaryCall<SearchArtistsRequest, SearchArtistsResponse>;
  searchAlbums: handleUnaryCall<SearchAlbumsRequest, SearchAlbumsResponse>;
}

export interface YTScraperClient extends Client {
  getSearchSuggestions(
    request: GetSearchSuggestionsRequest,
    callback: (error: ServiceError | null, response: GetSearchSuggestionsResponse) => void,
  ): ClientUnaryCall;
  getSearchSuggestions(
    request: GetSearchSuggestionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSearchSuggestionsResponse) => void,
  ): ClientUnaryCall;
  getSearchSuggestions(
    request: GetSearchSuggestionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSearchSuggestionsResponse) => void,
  ): ClientUnaryCall;
  getQuickPicks(
    request: GetQuickPicksRequest,
    callback: (error: ServiceError | null, response: GetQuickPicksResponse) => void,
  ): ClientUnaryCall;
  getQuickPicks(
    request: GetQuickPicksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetQuickPicksResponse) => void,
  ): ClientUnaryCall;
  getQuickPicks(
    request: GetQuickPicksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetQuickPicksResponse) => void,
  ): ClientUnaryCall;
  getAlbumDetails(
    request: GetAlbumDetailsRequest,
    callback: (error: ServiceError | null, response: GetAlbumDetailsResponse) => void,
  ): ClientUnaryCall;
  getAlbumDetails(
    request: GetAlbumDetailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAlbumDetailsResponse) => void,
  ): ClientUnaryCall;
  getAlbumDetails(
    request: GetAlbumDetailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAlbumDetailsResponse) => void,
  ): ClientUnaryCall;
  getArtistDetails(
    request: GetArtistDetailsRequest,
    callback: (error: ServiceError | null, response: GetArtistDetailsResponse) => void,
  ): ClientUnaryCall;
  getArtistDetails(
    request: GetArtistDetailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetArtistDetailsResponse) => void,
  ): ClientUnaryCall;
  getArtistDetails(
    request: GetArtistDetailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetArtistDetailsResponse) => void,
  ): ClientUnaryCall;
  searchTracks(
    request: SearchTracksRequest,
    callback: (error: ServiceError | null, response: SearchTracksResponse) => void,
  ): ClientUnaryCall;
  searchTracks(
    request: SearchTracksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchTracksResponse) => void,
  ): ClientUnaryCall;
  searchTracks(
    request: SearchTracksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchTracksResponse) => void,
  ): ClientUnaryCall;
  searchArtists(
    request: SearchArtistsRequest,
    callback: (error: ServiceError | null, response: SearchArtistsResponse) => void,
  ): ClientUnaryCall;
  searchArtists(
    request: SearchArtistsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchArtistsResponse) => void,
  ): ClientUnaryCall;
  searchArtists(
    request: SearchArtistsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchArtistsResponse) => void,
  ): ClientUnaryCall;
  searchAlbums(
    request: SearchAlbumsRequest,
    callback: (error: ServiceError | null, response: SearchAlbumsResponse) => void,
  ): ClientUnaryCall;
  searchAlbums(
    request: SearchAlbumsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchAlbumsResponse) => void,
  ): ClientUnaryCall;
  searchAlbums(
    request: SearchAlbumsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchAlbumsResponse) => void,
  ): ClientUnaryCall;
}

export const YTScraperClient = makeGenericClientConstructor(YTScraperService, "yt_scraper.YTScraper") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): YTScraperClient;
  service: typeof YTScraperService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
