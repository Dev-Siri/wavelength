// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.1
// source: proto/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "common";

/** Contains all data representations. */
export enum VideoType {
  VIDEO_TYPE_UNSPECIFIED = 0,
  VIDEO_TYPE_TRACK = 1,
  VIDEO_TYPE_UVIDEO = 2,
  UNRECOGNIZED = -1,
}

export function videoTypeFromJSON(object: any): VideoType {
  switch (object) {
    case 0:
    case "VIDEO_TYPE_UNSPECIFIED":
      return VideoType.VIDEO_TYPE_UNSPECIFIED;
    case 1:
    case "VIDEO_TYPE_TRACK":
      return VideoType.VIDEO_TYPE_TRACK;
    case 2:
    case "VIDEO_TYPE_UVIDEO":
      return VideoType.VIDEO_TYPE_UVIDEO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VideoType.UNRECOGNIZED;
  }
}

export function videoTypeToJSON(object: VideoType): string {
  switch (object) {
    case VideoType.VIDEO_TYPE_UNSPECIFIED:
      return "VIDEO_TYPE_UNSPECIFIED";
    case VideoType.VIDEO_TYPE_TRACK:
      return "VIDEO_TYPE_TRACK";
    case VideoType.VIDEO_TYPE_UVIDEO:
      return "VIDEO_TYPE_UVIDEO";
    case VideoType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AlbumType {
  ALBUM_TYPE_UNSPECIFIED = 0,
  ALBUM_TYPE_ALBUM = 1,
  ALBUM_TYPE_SINGLE = 2,
  ALBUM_TYPE_EP = 3,
  UNRECOGNIZED = -1,
}

export function albumTypeFromJSON(object: any): AlbumType {
  switch (object) {
    case 0:
    case "ALBUM_TYPE_UNSPECIFIED":
      return AlbumType.ALBUM_TYPE_UNSPECIFIED;
    case 1:
    case "ALBUM_TYPE_ALBUM":
      return AlbumType.ALBUM_TYPE_ALBUM;
    case 2:
    case "ALBUM_TYPE_SINGLE":
      return AlbumType.ALBUM_TYPE_SINGLE;
    case 3:
    case "ALBUM_TYPE_EP":
      return AlbumType.ALBUM_TYPE_EP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlbumType.UNRECOGNIZED;
  }
}

export function albumTypeToJSON(object: AlbumType): string {
  switch (object) {
    case AlbumType.ALBUM_TYPE_UNSPECIFIED:
      return "ALBUM_TYPE_UNSPECIFIED";
    case AlbumType.ALBUM_TYPE_ALBUM:
      return "ALBUM_TYPE_ALBUM";
    case AlbumType.ALBUM_TYPE_SINGLE:
      return "ALBUM_TYPE_SINGLE";
    case AlbumType.ALBUM_TYPE_EP:
      return "ALBUM_TYPE_EP";
    case AlbumType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Playlist {
  playlistId: string;
  name: string;
  authorGoogleEmail: string;
  authorName: string;
  authorImage: string;
  isPublic?: boolean | undefined;
  coverImage?: string | undefined;
}

export interface PlaylistTrack {
  playlistTrackId: string;
  title: string;
  thumbnail: string;
  positionInPlaylist: number;
  isExplicit?: boolean | undefined;
  duration: number;
  videoId: string;
  videoType: VideoType;
  playlistId: string;
  artists: EmbeddedArtist[];
  album?: EmbeddedAlbum | undefined;
}

export interface TracksLength {
  songCount: number;
  songDurationSecond: number;
}

export interface LikedTrack {
  likeId: string;
  email: string;
  title: string;
  thumbnail: string;
  isExplicit?: boolean | undefined;
  duration: number;
  videoId: string;
  videoType: VideoType;
  artists: EmbeddedArtist[];
  album?: EmbeddedAlbum | undefined;
}

export interface SuggestedLink {
  thumbnail: string;
  title: string;
  subtitle: string;
  browseId: string;
  type: string;
}

/**
 * Embedded types are made to be small and use as a part of a larger type.
 * These do not contain much information about their respective representations.
 */
export interface EmbeddedAlbum {
  browseId: string;
  title: string;
}

export interface EmbeddedArtist {
  browseId: string;
  title: string;
}

export interface QuickPick {
  videoId: string;
  title: string;
  thumbnail: string;
  artists: EmbeddedArtist[];
  album?: EmbeddedAlbum | undefined;
}

export interface MusicTrackStats {
  viewCount: number;
  likeCount: number;
  commentCount: number;
}

export interface YouTubeVideo {
  videoId: string;
  title: string;
  thumbnail: string;
  author: string;
  authorChannelId: string;
}

export interface AlbumTrack {
  videoId: string;
  title: string;
  duration: number;
  positionInAlbum: number;
  isExplicit?: boolean | undefined;
}

export interface Album {
  title: string;
  albumType: AlbumType;
  release: string;
  cover: string;
  totalSongCount: number;
  totalDuration: string;
  artist: EmbeddedArtist | undefined;
  albumTracks: AlbumTrack[];
}

export interface Track {
  videoId: string;
  title: string;
  thumbnail: string;
  duration: number;
  artists: EmbeddedArtist[];
  isExplicit?: boolean | undefined;
  album?: EmbeddedAlbum | undefined;
}

/** SearchArtist is the message returned when you search for artists. */
export interface SearchArtist {
  browseId: string;
  title: string;
  thumbnail: string;
  audience: string;
}

/** Artist is the message returned when you get an artist's details. */
export interface Artist {
  browseId: string;
  title: string;
  thumbnail: string;
  description: string;
  audience: string;
  topSongs: Artist_TopSongTrack[];
  albums: Artist_ArtistAlbum[];
  singlesAndEps: Artist_ArtistAlbum[];
}

export interface Artist_TopSongTrack {
  videoId: string;
  title: string;
  thumbnail: string;
  playCount: string;
  isExplicit?: boolean | undefined;
  album?: EmbeddedAlbum | undefined;
}

export interface Artist_ArtistAlbum {
  albumId: string;
  title: string;
  thumbnail: string;
  releaseDate: string;
  albumType: AlbumType;
}

export interface SearchAlbum {
  albumId: string;
  title: string;
  thumbnail: string;
  releaseDate: string;
  albumType: AlbumType;
  artist: EmbeddedArtist | undefined;
}

export interface FollowedArtist {
  followId: string;
  browseId: string;
  followerEmail: string;
  name: string;
  thumbnail: string;
}

export interface ThemeColor {
  r: number;
  g: number;
  b: number;
}

function createBasePlaylist(): Playlist {
  return {
    playlistId: "",
    name: "",
    authorGoogleEmail: "",
    authorName: "",
    authorImage: "",
    isPublic: undefined,
    coverImage: undefined,
  };
}

export const Playlist: MessageFns<Playlist> = {
  encode(message: Playlist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playlistId !== "") {
      writer.uint32(10).string(message.playlistId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.authorGoogleEmail !== "") {
      writer.uint32(26).string(message.authorGoogleEmail);
    }
    if (message.authorName !== "") {
      writer.uint32(34).string(message.authorName);
    }
    if (message.authorImage !== "") {
      writer.uint32(42).string(message.authorImage);
    }
    if (message.isPublic !== undefined) {
      writer.uint32(48).bool(message.isPublic);
    }
    if (message.coverImage !== undefined) {
      writer.uint32(58).string(message.coverImage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Playlist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaylist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playlistId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authorGoogleEmail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authorName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authorImage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.coverImage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Playlist {
    return {
      playlistId: isSet(object.playlistId) ? globalThis.String(object.playlistId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      authorGoogleEmail: isSet(object.authorGoogleEmail) ? globalThis.String(object.authorGoogleEmail) : "",
      authorName: isSet(object.authorName) ? globalThis.String(object.authorName) : "",
      authorImage: isSet(object.authorImage) ? globalThis.String(object.authorImage) : "",
      isPublic: isSet(object.isPublic) ? globalThis.Boolean(object.isPublic) : undefined,
      coverImage: isSet(object.coverImage) ? globalThis.String(object.coverImage) : undefined,
    };
  },

  toJSON(message: Playlist): unknown {
    const obj: any = {};
    if (message.playlistId !== "") {
      obj.playlistId = message.playlistId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authorGoogleEmail !== "") {
      obj.authorGoogleEmail = message.authorGoogleEmail;
    }
    if (message.authorName !== "") {
      obj.authorName = message.authorName;
    }
    if (message.authorImage !== "") {
      obj.authorImage = message.authorImage;
    }
    if (message.isPublic !== undefined) {
      obj.isPublic = message.isPublic;
    }
    if (message.coverImage !== undefined) {
      obj.coverImage = message.coverImage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Playlist>, I>>(base?: I): Playlist {
    return Playlist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Playlist>, I>>(object: I): Playlist {
    const message = createBasePlaylist();
    message.playlistId = object.playlistId ?? "";
    message.name = object.name ?? "";
    message.authorGoogleEmail = object.authorGoogleEmail ?? "";
    message.authorName = object.authorName ?? "";
    message.authorImage = object.authorImage ?? "";
    message.isPublic = object.isPublic ?? undefined;
    message.coverImage = object.coverImage ?? undefined;
    return message;
  },
};

function createBasePlaylistTrack(): PlaylistTrack {
  return {
    playlistTrackId: "",
    title: "",
    thumbnail: "",
    positionInPlaylist: 0,
    isExplicit: undefined,
    duration: 0,
    videoId: "",
    videoType: 0,
    playlistId: "",
    artists: [],
    album: undefined,
  };
}

export const PlaylistTrack: MessageFns<PlaylistTrack> = {
  encode(message: PlaylistTrack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playlistTrackId !== "") {
      writer.uint32(10).string(message.playlistTrackId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    if (message.positionInPlaylist !== 0) {
      writer.uint32(32).uint32(message.positionInPlaylist);
    }
    if (message.isExplicit !== undefined) {
      writer.uint32(40).bool(message.isExplicit);
    }
    if (message.duration !== 0) {
      writer.uint32(56).uint64(message.duration);
    }
    if (message.videoId !== "") {
      writer.uint32(66).string(message.videoId);
    }
    if (message.videoType !== 0) {
      writer.uint32(72).int32(message.videoType);
    }
    if (message.playlistId !== "") {
      writer.uint32(82).string(message.playlistId);
    }
    for (const v of message.artists) {
      EmbeddedArtist.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.album !== undefined) {
      EmbeddedAlbum.encode(message.album, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaylistTrack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaylistTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playlistTrackId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.positionInPlaylist = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isExplicit = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.duration = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.videoId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.videoType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.playlistId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.artists.push(EmbeddedArtist.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.album = EmbeddedAlbum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaylistTrack {
    return {
      playlistTrackId: isSet(object.playlistTrackId) ? globalThis.String(object.playlistTrackId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      positionInPlaylist: isSet(object.positionInPlaylist) ? globalThis.Number(object.positionInPlaylist) : 0,
      isExplicit: isSet(object.isExplicit) ? globalThis.Boolean(object.isExplicit) : undefined,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      videoType: isSet(object.videoType) ? videoTypeFromJSON(object.videoType) : 0,
      playlistId: isSet(object.playlistId) ? globalThis.String(object.playlistId) : "",
      artists: globalThis.Array.isArray(object?.artists)
        ? object.artists.map((e: any) => EmbeddedArtist.fromJSON(e))
        : [],
      album: isSet(object.album) ? EmbeddedAlbum.fromJSON(object.album) : undefined,
    };
  },

  toJSON(message: PlaylistTrack): unknown {
    const obj: any = {};
    if (message.playlistTrackId !== "") {
      obj.playlistTrackId = message.playlistTrackId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.positionInPlaylist !== 0) {
      obj.positionInPlaylist = Math.round(message.positionInPlaylist);
    }
    if (message.isExplicit !== undefined) {
      obj.isExplicit = message.isExplicit;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.videoType !== 0) {
      obj.videoType = videoTypeToJSON(message.videoType);
    }
    if (message.playlistId !== "") {
      obj.playlistId = message.playlistId;
    }
    if (message.artists?.length) {
      obj.artists = message.artists.map((e) => EmbeddedArtist.toJSON(e));
    }
    if (message.album !== undefined) {
      obj.album = EmbeddedAlbum.toJSON(message.album);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaylistTrack>, I>>(base?: I): PlaylistTrack {
    return PlaylistTrack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaylistTrack>, I>>(object: I): PlaylistTrack {
    const message = createBasePlaylistTrack();
    message.playlistTrackId = object.playlistTrackId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.positionInPlaylist = object.positionInPlaylist ?? 0;
    message.isExplicit = object.isExplicit ?? undefined;
    message.duration = object.duration ?? 0;
    message.videoId = object.videoId ?? "";
    message.videoType = object.videoType ?? 0;
    message.playlistId = object.playlistId ?? "";
    message.artists = object.artists?.map((e) => EmbeddedArtist.fromPartial(e)) || [];
    message.album = (object.album !== undefined && object.album !== null)
      ? EmbeddedAlbum.fromPartial(object.album)
      : undefined;
    return message;
  },
};

function createBaseTracksLength(): TracksLength {
  return { songCount: 0, songDurationSecond: 0 };
}

export const TracksLength: MessageFns<TracksLength> = {
  encode(message: TracksLength, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.songCount !== 0) {
      writer.uint32(8).uint64(message.songCount);
    }
    if (message.songDurationSecond !== 0) {
      writer.uint32(16).uint64(message.songDurationSecond);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TracksLength {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTracksLength();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.songCount = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.songDurationSecond = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TracksLength {
    return {
      songCount: isSet(object.songCount) ? globalThis.Number(object.songCount) : 0,
      songDurationSecond: isSet(object.songDurationSecond) ? globalThis.Number(object.songDurationSecond) : 0,
    };
  },

  toJSON(message: TracksLength): unknown {
    const obj: any = {};
    if (message.songCount !== 0) {
      obj.songCount = Math.round(message.songCount);
    }
    if (message.songDurationSecond !== 0) {
      obj.songDurationSecond = Math.round(message.songDurationSecond);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TracksLength>, I>>(base?: I): TracksLength {
    return TracksLength.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TracksLength>, I>>(object: I): TracksLength {
    const message = createBaseTracksLength();
    message.songCount = object.songCount ?? 0;
    message.songDurationSecond = object.songDurationSecond ?? 0;
    return message;
  },
};

function createBaseLikedTrack(): LikedTrack {
  return {
    likeId: "",
    email: "",
    title: "",
    thumbnail: "",
    isExplicit: undefined,
    duration: 0,
    videoId: "",
    videoType: 0,
    artists: [],
    album: undefined,
  };
}

export const LikedTrack: MessageFns<LikedTrack> = {
  encode(message: LikedTrack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.likeId !== "") {
      writer.uint32(10).string(message.likeId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(34).string(message.thumbnail);
    }
    if (message.isExplicit !== undefined) {
      writer.uint32(40).bool(message.isExplicit);
    }
    if (message.duration !== 0) {
      writer.uint32(48).uint64(message.duration);
    }
    if (message.videoId !== "") {
      writer.uint32(58).string(message.videoId);
    }
    if (message.videoType !== 0) {
      writer.uint32(64).int32(message.videoType);
    }
    for (const v of message.artists) {
      EmbeddedArtist.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.album !== undefined) {
      EmbeddedAlbum.encode(message.album, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LikedTrack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLikedTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.likeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isExplicit = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.videoId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.videoType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.artists.push(EmbeddedArtist.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.album = EmbeddedAlbum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LikedTrack {
    return {
      likeId: isSet(object.likeId) ? globalThis.String(object.likeId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      isExplicit: isSet(object.isExplicit) ? globalThis.Boolean(object.isExplicit) : undefined,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      videoType: isSet(object.videoType) ? videoTypeFromJSON(object.videoType) : 0,
      artists: globalThis.Array.isArray(object?.artists)
        ? object.artists.map((e: any) => EmbeddedArtist.fromJSON(e))
        : [],
      album: isSet(object.album) ? EmbeddedAlbum.fromJSON(object.album) : undefined,
    };
  },

  toJSON(message: LikedTrack): unknown {
    const obj: any = {};
    if (message.likeId !== "") {
      obj.likeId = message.likeId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.isExplicit !== undefined) {
      obj.isExplicit = message.isExplicit;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.videoType !== 0) {
      obj.videoType = videoTypeToJSON(message.videoType);
    }
    if (message.artists?.length) {
      obj.artists = message.artists.map((e) => EmbeddedArtist.toJSON(e));
    }
    if (message.album !== undefined) {
      obj.album = EmbeddedAlbum.toJSON(message.album);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LikedTrack>, I>>(base?: I): LikedTrack {
    return LikedTrack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LikedTrack>, I>>(object: I): LikedTrack {
    const message = createBaseLikedTrack();
    message.likeId = object.likeId ?? "";
    message.email = object.email ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.isExplicit = object.isExplicit ?? undefined;
    message.duration = object.duration ?? 0;
    message.videoId = object.videoId ?? "";
    message.videoType = object.videoType ?? 0;
    message.artists = object.artists?.map((e) => EmbeddedArtist.fromPartial(e)) || [];
    message.album = (object.album !== undefined && object.album !== null)
      ? EmbeddedAlbum.fromPartial(object.album)
      : undefined;
    return message;
  },
};

function createBaseSuggestedLink(): SuggestedLink {
  return { thumbnail: "", title: "", subtitle: "", browseId: "", type: "" };
}

export const SuggestedLink: MessageFns<SuggestedLink> = {
  encode(message: SuggestedLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.thumbnail !== "") {
      writer.uint32(10).string(message.thumbnail);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.subtitle !== "") {
      writer.uint32(26).string(message.subtitle);
    }
    if (message.browseId !== "") {
      writer.uint32(34).string(message.browseId);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestedLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestedLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subtitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.browseId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestedLink {
    return {
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      subtitle: isSet(object.subtitle) ? globalThis.String(object.subtitle) : "",
      browseId: isSet(object.browseId) ? globalThis.String(object.browseId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: SuggestedLink): unknown {
    const obj: any = {};
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.subtitle !== "") {
      obj.subtitle = message.subtitle;
    }
    if (message.browseId !== "") {
      obj.browseId = message.browseId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuggestedLink>, I>>(base?: I): SuggestedLink {
    return SuggestedLink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuggestedLink>, I>>(object: I): SuggestedLink {
    const message = createBaseSuggestedLink();
    message.thumbnail = object.thumbnail ?? "";
    message.title = object.title ?? "";
    message.subtitle = object.subtitle ?? "";
    message.browseId = object.browseId ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseEmbeddedAlbum(): EmbeddedAlbum {
  return { browseId: "", title: "" };
}

export const EmbeddedAlbum: MessageFns<EmbeddedAlbum> = {
  encode(message: EmbeddedAlbum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.browseId !== "") {
      writer.uint32(10).string(message.browseId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbeddedAlbum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbeddedAlbum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.browseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbeddedAlbum {
    return {
      browseId: isSet(object.browseId) ? globalThis.String(object.browseId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: EmbeddedAlbum): unknown {
    const obj: any = {};
    if (message.browseId !== "") {
      obj.browseId = message.browseId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbeddedAlbum>, I>>(base?: I): EmbeddedAlbum {
    return EmbeddedAlbum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbeddedAlbum>, I>>(object: I): EmbeddedAlbum {
    const message = createBaseEmbeddedAlbum();
    message.browseId = object.browseId ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseEmbeddedArtist(): EmbeddedArtist {
  return { browseId: "", title: "" };
}

export const EmbeddedArtist: MessageFns<EmbeddedArtist> = {
  encode(message: EmbeddedArtist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.browseId !== "") {
      writer.uint32(10).string(message.browseId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbeddedArtist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbeddedArtist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.browseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbeddedArtist {
    return {
      browseId: isSet(object.browseId) ? globalThis.String(object.browseId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: EmbeddedArtist): unknown {
    const obj: any = {};
    if (message.browseId !== "") {
      obj.browseId = message.browseId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbeddedArtist>, I>>(base?: I): EmbeddedArtist {
    return EmbeddedArtist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbeddedArtist>, I>>(object: I): EmbeddedArtist {
    const message = createBaseEmbeddedArtist();
    message.browseId = object.browseId ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseQuickPick(): QuickPick {
  return { videoId: "", title: "", thumbnail: "", artists: [], album: undefined };
}

export const QuickPick: MessageFns<QuickPick> = {
  encode(message: QuickPick, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(10).string(message.videoId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    for (const v of message.artists) {
      EmbeddedArtist.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.album !== undefined) {
      EmbeddedAlbum.encode(message.album, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuickPick {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuickPick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.artists.push(EmbeddedArtist.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.album = EmbeddedAlbum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuickPick {
    return {
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      artists: globalThis.Array.isArray(object?.artists)
        ? object.artists.map((e: any) => EmbeddedArtist.fromJSON(e))
        : [],
      album: isSet(object.album) ? EmbeddedAlbum.fromJSON(object.album) : undefined,
    };
  },

  toJSON(message: QuickPick): unknown {
    const obj: any = {};
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.artists?.length) {
      obj.artists = message.artists.map((e) => EmbeddedArtist.toJSON(e));
    }
    if (message.album !== undefined) {
      obj.album = EmbeddedAlbum.toJSON(message.album);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuickPick>, I>>(base?: I): QuickPick {
    return QuickPick.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuickPick>, I>>(object: I): QuickPick {
    const message = createBaseQuickPick();
    message.videoId = object.videoId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.artists = object.artists?.map((e) => EmbeddedArtist.fromPartial(e)) || [];
    message.album = (object.album !== undefined && object.album !== null)
      ? EmbeddedAlbum.fromPartial(object.album)
      : undefined;
    return message;
  },
};

function createBaseMusicTrackStats(): MusicTrackStats {
  return { viewCount: 0, likeCount: 0, commentCount: 0 };
}

export const MusicTrackStats: MessageFns<MusicTrackStats> = {
  encode(message: MusicTrackStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.viewCount !== 0) {
      writer.uint32(8).uint64(message.viewCount);
    }
    if (message.likeCount !== 0) {
      writer.uint32(16).uint64(message.likeCount);
    }
    if (message.commentCount !== 0) {
      writer.uint32(24).uint64(message.commentCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MusicTrackStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMusicTrackStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.viewCount = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.likeCount = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.commentCount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MusicTrackStats {
    return {
      viewCount: isSet(object.viewCount) ? globalThis.Number(object.viewCount) : 0,
      likeCount: isSet(object.likeCount) ? globalThis.Number(object.likeCount) : 0,
      commentCount: isSet(object.commentCount) ? globalThis.Number(object.commentCount) : 0,
    };
  },

  toJSON(message: MusicTrackStats): unknown {
    const obj: any = {};
    if (message.viewCount !== 0) {
      obj.viewCount = Math.round(message.viewCount);
    }
    if (message.likeCount !== 0) {
      obj.likeCount = Math.round(message.likeCount);
    }
    if (message.commentCount !== 0) {
      obj.commentCount = Math.round(message.commentCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MusicTrackStats>, I>>(base?: I): MusicTrackStats {
    return MusicTrackStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MusicTrackStats>, I>>(object: I): MusicTrackStats {
    const message = createBaseMusicTrackStats();
    message.viewCount = object.viewCount ?? 0;
    message.likeCount = object.likeCount ?? 0;
    message.commentCount = object.commentCount ?? 0;
    return message;
  },
};

function createBaseYouTubeVideo(): YouTubeVideo {
  return { videoId: "", title: "", thumbnail: "", author: "", authorChannelId: "" };
}

export const YouTubeVideo: MessageFns<YouTubeVideo> = {
  encode(message: YouTubeVideo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(10).string(message.videoId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    if (message.author !== "") {
      writer.uint32(34).string(message.author);
    }
    if (message.authorChannelId !== "") {
      writer.uint32(42).string(message.authorChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YouTubeVideo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYouTubeVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.author = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authorChannelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YouTubeVideo {
    return {
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      author: isSet(object.author) ? globalThis.String(object.author) : "",
      authorChannelId: isSet(object.authorChannelId) ? globalThis.String(object.authorChannelId) : "",
    };
  },

  toJSON(message: YouTubeVideo): unknown {
    const obj: any = {};
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.authorChannelId !== "") {
      obj.authorChannelId = message.authorChannelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YouTubeVideo>, I>>(base?: I): YouTubeVideo {
    return YouTubeVideo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YouTubeVideo>, I>>(object: I): YouTubeVideo {
    const message = createBaseYouTubeVideo();
    message.videoId = object.videoId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.author = object.author ?? "";
    message.authorChannelId = object.authorChannelId ?? "";
    return message;
  },
};

function createBaseAlbumTrack(): AlbumTrack {
  return { videoId: "", title: "", duration: 0, positionInAlbum: 0, isExplicit: undefined };
}

export const AlbumTrack: MessageFns<AlbumTrack> = {
  encode(message: AlbumTrack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(10).string(message.videoId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.duration !== 0) {
      writer.uint32(24).uint64(message.duration);
    }
    if (message.positionInAlbum !== 0) {
      writer.uint32(32).uint32(message.positionInAlbum);
    }
    if (message.isExplicit !== undefined) {
      writer.uint32(40).bool(message.isExplicit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlbumTrack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlbumTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.positionInAlbum = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isExplicit = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlbumTrack {
    return {
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      positionInAlbum: isSet(object.positionInAlbum) ? globalThis.Number(object.positionInAlbum) : 0,
      isExplicit: isSet(object.isExplicit) ? globalThis.Boolean(object.isExplicit) : undefined,
    };
  },

  toJSON(message: AlbumTrack): unknown {
    const obj: any = {};
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.positionInAlbum !== 0) {
      obj.positionInAlbum = Math.round(message.positionInAlbum);
    }
    if (message.isExplicit !== undefined) {
      obj.isExplicit = message.isExplicit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlbumTrack>, I>>(base?: I): AlbumTrack {
    return AlbumTrack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlbumTrack>, I>>(object: I): AlbumTrack {
    const message = createBaseAlbumTrack();
    message.videoId = object.videoId ?? "";
    message.title = object.title ?? "";
    message.duration = object.duration ?? 0;
    message.positionInAlbum = object.positionInAlbum ?? 0;
    message.isExplicit = object.isExplicit ?? undefined;
    return message;
  },
};

function createBaseAlbum(): Album {
  return {
    title: "",
    albumType: 0,
    release: "",
    cover: "",
    totalSongCount: 0,
    totalDuration: "",
    artist: undefined,
    albumTracks: [],
  };
}

export const Album: MessageFns<Album> = {
  encode(message: Album, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.albumType !== 0) {
      writer.uint32(16).int32(message.albumType);
    }
    if (message.release !== "") {
      writer.uint32(26).string(message.release);
    }
    if (message.cover !== "") {
      writer.uint32(34).string(message.cover);
    }
    if (message.totalSongCount !== 0) {
      writer.uint32(40).uint32(message.totalSongCount);
    }
    if (message.totalDuration !== "") {
      writer.uint32(50).string(message.totalDuration);
    }
    if (message.artist !== undefined) {
      EmbeddedArtist.encode(message.artist, writer.uint32(58).fork()).join();
    }
    for (const v of message.albumTracks) {
      AlbumTrack.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Album {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlbum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.albumType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.release = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cover = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalSongCount = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.totalDuration = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.artist = EmbeddedArtist.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.albumTracks.push(AlbumTrack.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Album {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      albumType: isSet(object.albumType) ? albumTypeFromJSON(object.albumType) : 0,
      release: isSet(object.release) ? globalThis.String(object.release) : "",
      cover: isSet(object.cover) ? globalThis.String(object.cover) : "",
      totalSongCount: isSet(object.totalSongCount) ? globalThis.Number(object.totalSongCount) : 0,
      totalDuration: isSet(object.totalDuration) ? globalThis.String(object.totalDuration) : "",
      artist: isSet(object.artist) ? EmbeddedArtist.fromJSON(object.artist) : undefined,
      albumTracks: globalThis.Array.isArray(object?.albumTracks)
        ? object.albumTracks.map((e: any) => AlbumTrack.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Album): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.albumType !== 0) {
      obj.albumType = albumTypeToJSON(message.albumType);
    }
    if (message.release !== "") {
      obj.release = message.release;
    }
    if (message.cover !== "") {
      obj.cover = message.cover;
    }
    if (message.totalSongCount !== 0) {
      obj.totalSongCount = Math.round(message.totalSongCount);
    }
    if (message.totalDuration !== "") {
      obj.totalDuration = message.totalDuration;
    }
    if (message.artist !== undefined) {
      obj.artist = EmbeddedArtist.toJSON(message.artist);
    }
    if (message.albumTracks?.length) {
      obj.albumTracks = message.albumTracks.map((e) => AlbumTrack.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Album>, I>>(base?: I): Album {
    return Album.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Album>, I>>(object: I): Album {
    const message = createBaseAlbum();
    message.title = object.title ?? "";
    message.albumType = object.albumType ?? 0;
    message.release = object.release ?? "";
    message.cover = object.cover ?? "";
    message.totalSongCount = object.totalSongCount ?? 0;
    message.totalDuration = object.totalDuration ?? "";
    message.artist = (object.artist !== undefined && object.artist !== null)
      ? EmbeddedArtist.fromPartial(object.artist)
      : undefined;
    message.albumTracks = object.albumTracks?.map((e) => AlbumTrack.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrack(): Track {
  return { videoId: "", title: "", thumbnail: "", duration: 0, artists: [], isExplicit: undefined, album: undefined };
}

export const Track: MessageFns<Track> = {
  encode(message: Track, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(10).string(message.videoId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    if (message.duration !== 0) {
      writer.uint32(32).uint64(message.duration);
    }
    for (const v of message.artists) {
      EmbeddedArtist.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.isExplicit !== undefined) {
      writer.uint32(48).bool(message.isExplicit);
    }
    if (message.album !== undefined) {
      EmbeddedAlbum.encode(message.album, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Track {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.duration = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.artists.push(EmbeddedArtist.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isExplicit = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.album = EmbeddedAlbum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Track {
    return {
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      artists: globalThis.Array.isArray(object?.artists)
        ? object.artists.map((e: any) => EmbeddedArtist.fromJSON(e))
        : [],
      isExplicit: isSet(object.isExplicit) ? globalThis.Boolean(object.isExplicit) : undefined,
      album: isSet(object.album) ? EmbeddedAlbum.fromJSON(object.album) : undefined,
    };
  },

  toJSON(message: Track): unknown {
    const obj: any = {};
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.artists?.length) {
      obj.artists = message.artists.map((e) => EmbeddedArtist.toJSON(e));
    }
    if (message.isExplicit !== undefined) {
      obj.isExplicit = message.isExplicit;
    }
    if (message.album !== undefined) {
      obj.album = EmbeddedAlbum.toJSON(message.album);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Track>, I>>(base?: I): Track {
    return Track.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Track>, I>>(object: I): Track {
    const message = createBaseTrack();
    message.videoId = object.videoId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.duration = object.duration ?? 0;
    message.artists = object.artists?.map((e) => EmbeddedArtist.fromPartial(e)) || [];
    message.isExplicit = object.isExplicit ?? undefined;
    message.album = (object.album !== undefined && object.album !== null)
      ? EmbeddedAlbum.fromPartial(object.album)
      : undefined;
    return message;
  },
};

function createBaseSearchArtist(): SearchArtist {
  return { browseId: "", title: "", thumbnail: "", audience: "" };
}

export const SearchArtist: MessageFns<SearchArtist> = {
  encode(message: SearchArtist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.browseId !== "") {
      writer.uint32(10).string(message.browseId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    if (message.audience !== "") {
      writer.uint32(34).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchArtist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchArtist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.browseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.audience = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchArtist {
    return {
      browseId: isSet(object.browseId) ? globalThis.String(object.browseId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
    };
  },

  toJSON(message: SearchArtist): unknown {
    const obj: any = {};
    if (message.browseId !== "") {
      obj.browseId = message.browseId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchArtist>, I>>(base?: I): SearchArtist {
    return SearchArtist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchArtist>, I>>(object: I): SearchArtist {
    const message = createBaseSearchArtist();
    message.browseId = object.browseId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.audience = object.audience ?? "";
    return message;
  },
};

function createBaseArtist(): Artist {
  return {
    browseId: "",
    title: "",
    thumbnail: "",
    description: "",
    audience: "",
    topSongs: [],
    albums: [],
    singlesAndEps: [],
  };
}

export const Artist: MessageFns<Artist> = {
  encode(message: Artist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.browseId !== "") {
      writer.uint32(10).string(message.browseId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.audience !== "") {
      writer.uint32(42).string(message.audience);
    }
    for (const v of message.topSongs) {
      Artist_TopSongTrack.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.albums) {
      Artist_ArtistAlbum.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.singlesAndEps) {
      Artist_ArtistAlbum.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Artist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.browseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.audience = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.topSongs.push(Artist_TopSongTrack.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.albums.push(Artist_ArtistAlbum.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.singlesAndEps.push(Artist_ArtistAlbum.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artist {
    return {
      browseId: isSet(object.browseId) ? globalThis.String(object.browseId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
      topSongs: globalThis.Array.isArray(object?.topSongs)
        ? object.topSongs.map((e: any) => Artist_TopSongTrack.fromJSON(e))
        : [],
      albums: globalThis.Array.isArray(object?.albums)
        ? object.albums.map((e: any) => Artist_ArtistAlbum.fromJSON(e))
        : [],
      singlesAndEps: globalThis.Array.isArray(object?.singlesAndEps)
        ? object.singlesAndEps.map((e: any) => Artist_ArtistAlbum.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Artist): unknown {
    const obj: any = {};
    if (message.browseId !== "") {
      obj.browseId = message.browseId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    if (message.topSongs?.length) {
      obj.topSongs = message.topSongs.map((e) => Artist_TopSongTrack.toJSON(e));
    }
    if (message.albums?.length) {
      obj.albums = message.albums.map((e) => Artist_ArtistAlbum.toJSON(e));
    }
    if (message.singlesAndEps?.length) {
      obj.singlesAndEps = message.singlesAndEps.map((e) => Artist_ArtistAlbum.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Artist>, I>>(base?: I): Artist {
    return Artist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Artist>, I>>(object: I): Artist {
    const message = createBaseArtist();
    message.browseId = object.browseId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.description = object.description ?? "";
    message.audience = object.audience ?? "";
    message.topSongs = object.topSongs?.map((e) => Artist_TopSongTrack.fromPartial(e)) || [];
    message.albums = object.albums?.map((e) => Artist_ArtistAlbum.fromPartial(e)) || [];
    message.singlesAndEps = object.singlesAndEps?.map((e) => Artist_ArtistAlbum.fromPartial(e)) || [];
    return message;
  },
};

function createBaseArtist_TopSongTrack(): Artist_TopSongTrack {
  return { videoId: "", title: "", thumbnail: "", playCount: "", isExplicit: undefined, album: undefined };
}

export const Artist_TopSongTrack: MessageFns<Artist_TopSongTrack> = {
  encode(message: Artist_TopSongTrack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(10).string(message.videoId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    if (message.playCount !== "") {
      writer.uint32(34).string(message.playCount);
    }
    if (message.isExplicit !== undefined) {
      writer.uint32(40).bool(message.isExplicit);
    }
    if (message.album !== undefined) {
      EmbeddedAlbum.encode(message.album, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Artist_TopSongTrack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtist_TopSongTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.playCount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isExplicit = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.album = EmbeddedAlbum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artist_TopSongTrack {
    return {
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      playCount: isSet(object.playCount) ? globalThis.String(object.playCount) : "",
      isExplicit: isSet(object.isExplicit) ? globalThis.Boolean(object.isExplicit) : undefined,
      album: isSet(object.album) ? EmbeddedAlbum.fromJSON(object.album) : undefined,
    };
  },

  toJSON(message: Artist_TopSongTrack): unknown {
    const obj: any = {};
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.playCount !== "") {
      obj.playCount = message.playCount;
    }
    if (message.isExplicit !== undefined) {
      obj.isExplicit = message.isExplicit;
    }
    if (message.album !== undefined) {
      obj.album = EmbeddedAlbum.toJSON(message.album);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Artist_TopSongTrack>, I>>(base?: I): Artist_TopSongTrack {
    return Artist_TopSongTrack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Artist_TopSongTrack>, I>>(object: I): Artist_TopSongTrack {
    const message = createBaseArtist_TopSongTrack();
    message.videoId = object.videoId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.playCount = object.playCount ?? "";
    message.isExplicit = object.isExplicit ?? undefined;
    message.album = (object.album !== undefined && object.album !== null)
      ? EmbeddedAlbum.fromPartial(object.album)
      : undefined;
    return message;
  },
};

function createBaseArtist_ArtistAlbum(): Artist_ArtistAlbum {
  return { albumId: "", title: "", thumbnail: "", releaseDate: "", albumType: 0 };
}

export const Artist_ArtistAlbum: MessageFns<Artist_ArtistAlbum> = {
  encode(message: Artist_ArtistAlbum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.albumId !== "") {
      writer.uint32(10).string(message.albumId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    if (message.releaseDate !== "") {
      writer.uint32(34).string(message.releaseDate);
    }
    if (message.albumType !== 0) {
      writer.uint32(40).int32(message.albumType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Artist_ArtistAlbum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtist_ArtistAlbum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.albumId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.releaseDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.albumType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artist_ArtistAlbum {
    return {
      albumId: isSet(object.albumId) ? globalThis.String(object.albumId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      releaseDate: isSet(object.releaseDate) ? globalThis.String(object.releaseDate) : "",
      albumType: isSet(object.albumType) ? albumTypeFromJSON(object.albumType) : 0,
    };
  },

  toJSON(message: Artist_ArtistAlbum): unknown {
    const obj: any = {};
    if (message.albumId !== "") {
      obj.albumId = message.albumId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.releaseDate !== "") {
      obj.releaseDate = message.releaseDate;
    }
    if (message.albumType !== 0) {
      obj.albumType = albumTypeToJSON(message.albumType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Artist_ArtistAlbum>, I>>(base?: I): Artist_ArtistAlbum {
    return Artist_ArtistAlbum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Artist_ArtistAlbum>, I>>(object: I): Artist_ArtistAlbum {
    const message = createBaseArtist_ArtistAlbum();
    message.albumId = object.albumId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.releaseDate = object.releaseDate ?? "";
    message.albumType = object.albumType ?? 0;
    return message;
  },
};

function createBaseSearchAlbum(): SearchAlbum {
  return { albumId: "", title: "", thumbnail: "", releaseDate: "", albumType: 0, artist: undefined };
}

export const SearchAlbum: MessageFns<SearchAlbum> = {
  encode(message: SearchAlbum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.albumId !== "") {
      writer.uint32(10).string(message.albumId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.thumbnail !== "") {
      writer.uint32(26).string(message.thumbnail);
    }
    if (message.releaseDate !== "") {
      writer.uint32(34).string(message.releaseDate);
    }
    if (message.albumType !== 0) {
      writer.uint32(40).int32(message.albumType);
    }
    if (message.artist !== undefined) {
      EmbeddedArtist.encode(message.artist, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAlbum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAlbum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.albumId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.releaseDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.albumType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.artist = EmbeddedArtist.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAlbum {
    return {
      albumId: isSet(object.albumId) ? globalThis.String(object.albumId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      releaseDate: isSet(object.releaseDate) ? globalThis.String(object.releaseDate) : "",
      albumType: isSet(object.albumType) ? albumTypeFromJSON(object.albumType) : 0,
      artist: isSet(object.artist) ? EmbeddedArtist.fromJSON(object.artist) : undefined,
    };
  },

  toJSON(message: SearchAlbum): unknown {
    const obj: any = {};
    if (message.albumId !== "") {
      obj.albumId = message.albumId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.releaseDate !== "") {
      obj.releaseDate = message.releaseDate;
    }
    if (message.albumType !== 0) {
      obj.albumType = albumTypeToJSON(message.albumType);
    }
    if (message.artist !== undefined) {
      obj.artist = EmbeddedArtist.toJSON(message.artist);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchAlbum>, I>>(base?: I): SearchAlbum {
    return SearchAlbum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchAlbum>, I>>(object: I): SearchAlbum {
    const message = createBaseSearchAlbum();
    message.albumId = object.albumId ?? "";
    message.title = object.title ?? "";
    message.thumbnail = object.thumbnail ?? "";
    message.releaseDate = object.releaseDate ?? "";
    message.albumType = object.albumType ?? 0;
    message.artist = (object.artist !== undefined && object.artist !== null)
      ? EmbeddedArtist.fromPartial(object.artist)
      : undefined;
    return message;
  },
};

function createBaseFollowedArtist(): FollowedArtist {
  return { followId: "", browseId: "", followerEmail: "", name: "", thumbnail: "" };
}

export const FollowedArtist: MessageFns<FollowedArtist> = {
  encode(message: FollowedArtist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followId !== "") {
      writer.uint32(10).string(message.followId);
    }
    if (message.browseId !== "") {
      writer.uint32(18).string(message.browseId);
    }
    if (message.followerEmail !== "") {
      writer.uint32(26).string(message.followerEmail);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.thumbnail !== "") {
      writer.uint32(42).string(message.thumbnail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FollowedArtist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFollowedArtist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.followId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.browseId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.followerEmail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FollowedArtist {
    return {
      followId: isSet(object.followId) ? globalThis.String(object.followId) : "",
      browseId: isSet(object.browseId) ? globalThis.String(object.browseId) : "",
      followerEmail: isSet(object.followerEmail) ? globalThis.String(object.followerEmail) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
    };
  },

  toJSON(message: FollowedArtist): unknown {
    const obj: any = {};
    if (message.followId !== "") {
      obj.followId = message.followId;
    }
    if (message.browseId !== "") {
      obj.browseId = message.browseId;
    }
    if (message.followerEmail !== "") {
      obj.followerEmail = message.followerEmail;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FollowedArtist>, I>>(base?: I): FollowedArtist {
    return FollowedArtist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FollowedArtist>, I>>(object: I): FollowedArtist {
    const message = createBaseFollowedArtist();
    message.followId = object.followId ?? "";
    message.browseId = object.browseId ?? "";
    message.followerEmail = object.followerEmail ?? "";
    message.name = object.name ?? "";
    message.thumbnail = object.thumbnail ?? "";
    return message;
  },
};

function createBaseThemeColor(): ThemeColor {
  return { r: 0, g: 0, b: 0 };
}

export const ThemeColor: MessageFns<ThemeColor> = {
  encode(message: ThemeColor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.r !== 0) {
      writer.uint32(8).uint32(message.r);
    }
    if (message.g !== 0) {
      writer.uint32(16).uint32(message.g);
    }
    if (message.b !== 0) {
      writer.uint32(24).uint32(message.b);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThemeColor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThemeColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.r = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.g = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.b = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThemeColor {
    return {
      r: isSet(object.r) ? globalThis.Number(object.r) : 0,
      g: isSet(object.g) ? globalThis.Number(object.g) : 0,
      b: isSet(object.b) ? globalThis.Number(object.b) : 0,
    };
  },

  toJSON(message: ThemeColor): unknown {
    const obj: any = {};
    if (message.r !== 0) {
      obj.r = Math.round(message.r);
    }
    if (message.g !== 0) {
      obj.g = Math.round(message.g);
    }
    if (message.b !== 0) {
      obj.b = Math.round(message.b);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ThemeColor>, I>>(base?: I): ThemeColor {
    return ThemeColor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThemeColor>, I>>(object: I): ThemeColor {
    const message = createBaseThemeColor();
    message.r = object.r ?? 0;
    message.g = object.g ?? 0;
    message.b = object.b ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
